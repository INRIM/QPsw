% Simulates waveform generated by PJVS and sampled by ideal digitizer. It can
% work with non-coherent frequencies.
% 
% Inputs:
% f - main signal frequency (Hz)
% A - 'sine' wave amplitude (V)
% ph - 'sine' wave phase (rad)
% L - record length (samples)
% fs - sampling frequency (Hz)
% noise - signal noise sigma (V)
% fseg - frequency of PJVS segments (Hz)
% fm - microwave frequency (Hz)
% apply_filter - if nonzero, applies digital filter simulating sigma delta 
% digitizer (bool)
% 
% Outputs:
% y - waveform (V)
% n - quantum numbers in every segment (int)
% U - reference voltages of segments (V)
% Sid - sample indexes of PJVS switches - switch happen before the sample

function [y, n, Uref, Sid] = pjvs_wvfrm_generator(f, A, ph, L, fs, noise, fseg, fm, apply_filter)
    % set values of optional inputs %<<<1
    % check inputs %<<<1
    if fseg >= fs
        error('pjvs_wvfrm_generator: frequency of segments is equal or greater than sampling frequency')
    end
    if f >= fs
        error('pjvs_wvfrm_generator: signal frequency is equal or greater than sampling frequency')
    end

    % initialize values %<<<1
    % number of samples in one period of the signal:
    Ssig = fs/f;
    % number of samples in one PJVS segment:
    Sseg = fs/fseg;
    % minimal signal length needed in the script - must be divisible by 1/fseg
    % (the signal will be shortened to L if needed)
    SL = ceil(L/Sseg).*Sseg;
    % Josephson constant, 2e/h:
    h = 6.62607015e-34;
    e = 1.602176634e-19;
    KJ = 2*e/h; % (Hz/V)
    % voltage step for actual microwave frequency:
    VS = fm/KJ;

    % generate sine waveform %<<<1
    % time axis:
    t = [0:SL-1]./fs;
    % sine:
    ysine = A.*sin(2*pi*f.*t + ph);

    % quantize: %<<<1
    if Sseg == fix(Sseg) % fast method %<<<2
        % fast method for coherent settings:
        % reformat by segments
        % (the y matrix has many rows and columns equal to Sseg)
        ysine = reshape(ysine, Sseg, [])';
        % calculate average value in every segment:
        avg = mean(ysine, 2);
        % find quantum numbers for every segment:
        n = round(avg./VS);
        % construct output matrix by quantum numbers:
        y = repmat(n, 1, Sseg);
        % mutliply quantum numbers to get quantized voltages:
        y = y.*VS;
        % reformat back to single row vectors:
        ysine = reshape(ysine', 1, []);
        y = reshape(y', 1, []);
        n = n';
        Sid = [1:Sseg:SL-1];
    else % slow method %<<<2
        warning('non coherent settings (fs/fseg), using slow method!')
        % slow method for non coherent settings:
        ids = 1;
        y = [];
        n = [];
        Sid = 1;
        % for cycle is usually terminated by condition at end
        % SL is multiple of Sseg, so SL./Sseg is integer:
        for i = 1:ceil(SL./Sseg)
            % calculate index of new segment end:
            ide = round(Sseg.*i);
            if ide > SL
                ide = SL
            end
            % calculate quantum number
            segment = round(mean(ysine(ids:ide))./VS);
            n = [n segment];
            % add voltages:
            y = [y segment.*VS.*ones(1, ide-ids+1)];
            % next starting index:
            ids = ide + 1;
            % if index is too big, quit:
            if ids > SL
                break
            end
            Sid = [Sid ids];
        end % for i
    end
    % make reference voltages:
    Uref = n.*VS;

    % signal treating %<<<1
    % cut to required length:
    t = t(1:L);
    ysine = ysine(1:L);
    y = y(1:L);
    % add noise with normal distribution:
    y = y + normrnd(0, noise, size(y));

    % filter signal %<<<1
    if apply_filter
        % filtering is to simulate ADC response to PJVS jumps
        % butterworth filter of order 10
        % (For digital filters, the cutoff frequencies must lie between 0 and 1,
        % where 1 corresponds to the Nyquist rate—half the sample rate or π
        % rad/sample.)
        [b, a]=butter(10, 0.5);
        % apply filter forward and reverse to minimize phase shift and simulate
        % sigma delta filter of 5922:
        y = filtfilt(b,a,y);
    end % if apply_filter

    % % plotting - only for debug %<<<1
    % figure()
    % hold on
    % plot(t, ysine, '-b')
    % plot(t, y, '+-r')
    % legend('sine waveform', 'digitized PJVS signal', 'filtered')
    % hold off
    % xlabel('t (s)')
    % ylabel('u (V)')

end % function

% tests  %<<<1
% just test working function for terrible inputs:
%!shared f, A, ph, L, fs, noise, fseg, fm, y, n
%! f = 2;
%! A = 10;
%! ph = -0.2*pi;
%! L = 111;
%! fs = 233;
%! noise = 1e-1;
%! fseg = 17;
%! fm = 75e9;
%! [y, n] = pjvs_wvfrm_generator(f, A, ph, L, fs, noise, fseg, fm, 1);
%!assert(size(y, 2) == L);

% vim settings modeline: vim: foldmarker=%<<<,%>>> fdm=marker fen ft=octave textwidth=80 tabstop=4 shiftwidth=4
